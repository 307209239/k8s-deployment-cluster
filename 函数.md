Golang 中有3种函数类型：
*   普通带有名字的函数；
*   匿名函数和lambda函数；
*   方法；<br>

在 Golang 中函数定义的方式：
```
func (p myType ) funcName ( a, b int , c string ) ( r , s int ) {
    return
}
```
说明：<br>
关键字—— func <br>
函数名—— funcName <br>
参数体—— a,b int，c string <br>
返回值—— r,s int <br>
函数体—— { 代码块 } <br>
P myType —— 表示给 myType 声明一个方法,但并不是必须的;如果没有则是一个函数; <br>
#### 提示：
函数参数、返回值以及它们的类型被统称为函数签名。Go函数不支持函数嵌套、重载、默认参数。但是支持不定长度变参、多返回值、命名返回值、匿名函数、闭包等。也可以通过 type类型 来使用。
#### 1 函数参数与返回值(普通函数)
##### 1.1 按值传递、按引用传递
Go 默认使用按值传递来传递参数，也就是传递参数的副本。如果想函数可以直接修改参数的值，而不是对函数的副本进行操作，此时你可以将参数以指针的形式（变量前加&符号，指针也是变量类型，有自己的地址和值）进行传递。<br>
递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。<br>

##### 1.2 命名返回值和非命名返回值
命名返回值作为结果形参被初始化为相应类型的0值，当需要返回的时候，只需要不带参数的return语句即可。非命名的返回值，需要使用（）将他们扩起来。需要注意的是，命名返回值也需要使用 () 括起来。尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。
##### 函数例1
```
package main

import "fmt"

var num int = 10
var numx2, numx3 int

func main() {
    numx2, numx3 = getX2AndX3(num)
    PrintValues()
    numx2, numx3 = getX2AndX3_2(num)
    PrintValues()
}

func PrintValues() {
    fmt.Printf("num = %d, 2x num = %d, 3x num = %d\n", num, numx2, numx3)
}

func getX2AndX3(input int) (int, int) {                              //非命名返回值
    return 2 * input, 3 * input
}

func getX2AndX3_2(input int) (x2 int, x3 int) {                      //命名返回值
    x2 = 2 * input
    x3 = 3 * input
    // return x2, x3
    return
}
```
#### 2 可边长参数函数
函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0 。
##### 函数例2
```
package main

import "fmt"

// 可变参函数,变参本质上就是 slice; 只能有⼀个，且必须是最后⼀个;
func test1(s string, n ...int) string {
	var x int
	for _, i := range n {
		x += i
	}
	return fmt.Sprintf(s, x)
}

func main() {
	fmt.Println(test1("sum: %d", 1, 2, 3))
}
```
#### 3 递归函数
当一个函数在其函数体内调用自身，则称之为递归。
##### 函数例3
```
package main

import "fmt"

func fib(n int) int {
	if n == 1 || n == 2 {
		return 1
	}
	return fib(n - 1) + fib(n - 2)
}

func main()  {
	fmt.Println(fib(5))
}
```
##### 函数例3
```
//闭包函数
package main

import "fmt"

func main() {
	var fs = [4]func() {}
	for i := 0; i < 4; i ++ {
		defer fmt.Println("defer i =",i)
		defer func() { fmt.Println("defer_closure i = ", i) }()
		fs[i] = func() { fmt.Println("closure i = ",i) } 
	}
	for _, f := range fs {
		f()
	}
}
